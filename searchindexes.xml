<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>从0到1的成长见证-我的fnOS nas升级正式版体验分享</title><url>/post/system/fnos/fnos-experience-sharing/</url><categories><category>系统</category><category>飞牛OS</category></categories><tags><tag>fnOS</tag><tag>NAS</tag></tags><content type="html">  时光荏苒，转眼间与飞牛fnOS相伴已满一年。作为一位从早期测试版就开始使用的忠实用户，今天怀着无比激动的心情，与各位牛友分享我升级fnOS 1.0后的真实体验与感悟。
【我的NAS配置】 Nas 1（资料存储） CPU：Intel J1900 内存：8GB DDR3 1600MHz 存储：4盘位SATA架构 1×120GB JINGYI SSD（系统盘） 2×4TB Seagate IronWolf HDD（数据存储） 1×1TB Micron M600 SSD（缓存加速） 网络：2×1G ，聚合设计，增大线路带宽 机箱：经典蜗牛星际机箱 当前系统：fnOS 1.0.0 Nas 2（媒体存储 + 实验工作机） CPU：Intel QTJ0 主板：ASRock Z370 Taichi 内存：16GB DDR4 2400MHz 存储： M.2 NVMe：1×1TB Seagate FIRECUDA 520 + 1×4TB HIKVISION C4000 SATA：1×1TB Micron M600 SSD + 1×2TB Seagate IronWolf HDD 网络：1×10G（X520万兆网卡） + 2×1G ，多运营商宽带接入，对ipv4和ipv6流量分流选择不同线路 当前系统：fnOS 1.0.0 【升级体验：流畅如丝，安心无忧】 当1.0正式版的推送通知出现在管理界面时，内心涌起一阵期待。作为见证飞牛从0到1全过程的老用户，这次升级对我而言意义非凡。
升级过程令人惊喜：
从下载到完成升级仅用时3分钟，远超预期 全程数据安全无忧，所有应用和服务自动恢复 重启后系统响应速度明显提升，特别是文件管理器的操作流畅度实现了质的飞跃 界面动画更加细腻，系统资源占用率显著降低 【新功能深度体验】 🔹 FN Connect远程访问：重新定义远程连接 1.0版本在远程连接稳定性上实现了跨越式提升。实测数据显示，在外用手机4G网络访问家中NAS时：
视频加载速度提升近40% 连接中断率从之前的15%降至近乎0% 穿透成功率提升至98%以上 端到端延迟降低至200ms以内 🎬 多媒体中心：家庭娱乐新体验 全新的媒体库管理界面堪称视觉盛宴：
电影海报墙自动匹配准确率达95%以上 智能分类算法能自动识别影视作品的类型、年份、演员信息 音乐库支持无损格式自动封面匹配 照片智能识别功能让家 …  </content></entry><entry><title>Redis性能优化指南 内存管理与持久化策略实战</title><url>/post/operations/redis-optimization/</url><categories><category>运维</category><category>性能优化</category></categories><tags><tag>Redis</tag><tag>性能调优</tag><tag>内存优化</tag><tag>持久化</tag><tag>系统优化</tag><tag>数据库</tag><tag>监控</tag></tags><content type="html">  Redis 优化指南 Redis 是基于内存的键值数据库，其性能瓶颈通常在于内存、网络和持久化配置。
1. 内存管理 设置内存上限与淘汰策略 maxmemory 2gb：设置 Redis 可使用的最大内存，建议为系统物理内存的70%-80%，为系统和其他进程留出空间。 maxmemory-policy allkeys-lru：定义内存达到上限时的数据淘汰策略。 allkeys-lru（所有键中最近最少使用的）适用于缓存场景 若数据不能丢失，可使用 volatile-lru（仅淘汰设定了过期时间的键） 优化数据结构 使用 Hash（哈希）来存储对象（如用户信息），而不是为每个字段存储一个单独的 String，以减少 Key 的数量和内存元数据开销。 对于小型聚合数据，可通过 hash-max-ziplist-entries 等参数启用 ziplist 编码，节省内存。 2. 持久化策略 根据数据安全性和性能要求平衡 RDB 和 AOF。
RDB (快照) 生成数据快照，恢复快 配置示例： 1 2 3 save 900 1 # 900秒内至少1个key变化则触发快照 save 300 10 # 300秒内至少10个key变化 save 60 10000 # 60秒内至少10000个key变化 可根据数据变更频率调整 save 参数 AOF (追加文件) 记录每个写命令，数据安全性更高 配置示例： 1 2 appendonly yes # 启用AOF appendfsync everysec # 每秒同步一次，性能与安全平衡 appendfsync always：数据安全性最高，但性能下降严重 appendfsync no：由操作系统决定同步时机，性能最好但风险最高 混合持久化 (Redis 4.0+) 1 aof-use-rdb-preamble yes 结合 RDB 的快速恢复和 AOF 的增量数据安全，推荐使用 3. 内核与网络优化 系统内核参数 vm.overcommit_memory = 1：设置为1，允许内存超额分配，防止在生成 RDB 快照或 AOF 重写时因 fork 操作失败 禁用透明大页 (Transparent Huge Pages)： 1 echo never &amp;amp;gt; …  </content></entry><entry><title>Redis安装部署指南 Ubuntu 24.04 aarch64架构详细教程</title><url>/post/operations/redis-installation-ubuntu-24-04-aarch64/</url><categories><category>运维</category><category>部署</category></categories><tags><tag>Redis</tag><tag>Ubuntu</tag><tag>Linux</tag><tag>数据库</tag><tag>服务器配置</tag><tag>aarch64</tag><tag>系统管理</tag><tag>安全配置</tag></tags><content type="html">  Redis 安装部署（Ubuntu 24.04 aarch64） 在 Ubuntu 24.04.1 aarch64 系统上部署 Redis 有多种方法，可以根据对版本和控制度的需求来选择。下面整理了两种主流方案：使用系统自带的 APT 包管理器安装最简单快捷；如果需要最新版本或更灵活的配置，则推荐从源码编译安装。
特性 方法一：APT 安装 (推荐用于大多数情况) 方法二：源码编译安装 (推荐用于需要特定版本或深度定制) 安装难度 非常简单 中等，步骤较多 版本 系统仓库中的稳定版（可能非最新） 可安装任何版本（如最新的 7.2.4） 管理方式 通过 systemd 管理，命令简单统一 需手动配置 systemd 服务 灵活性 默认配置，修改相对受限 配置灵活，可完全控制安装路径和功能 方法一：通过 APT 安装 Redis 这是最快捷的方式，适合希望快速启用并投入使用的用户。
更新软件包列表： 首先确保你的系统软件包列表是最新的。
1 sudo apt update 安装 Redis 服务： 该命令会安装 Redis 服务器及其所有必要的依赖。
1 sudo apt install redis-server -y 验证安装与运行状态： 检查 Redis 服务是否正在正常运行。
1 sudo systemctl status redis-server 如果一切正常，你将看到状态显示为 active (running)。
方法二：从源码编译安装 Redis 此方法步骤较多，但能让你安装特定版本并拥有完全的配置控制权。以下是安装 Redis 7.2.4 的步骤。
1、安装编译依赖 在编译代码前，需要安装必要的开发工具。
1 2 sudo apt update sudo apt install build-essential tcl -y 2、下载并解压源码 从 Redis 官网下载你需要的版本源码并解压。
1 2 3 wget https://download.redis.io/releases/redis-7.2.4.tar.gz tar -zxvf redis-7.2.4.tar.gz cd redis-7.2.4 3、编译与安装 这个过程可能会花费几分钟。
1 2 make sudo make install 配置系统服务和管理 安装完成后，需要将其配置为系统服务 …  </content></entry><entry><title>Tomcat性能优化指南 JVM内存调优与线程池配置实战</title><url>/post/operations/tomcat-performance-optimization/</url><categories><category>运维</category><category>性能优化</category></categories><tags><tag>Tomcat</tag><tag>JVM</tag><tag>性能调优</tag><tag>Java</tag><tag>服务器优化</tag><tag>线程池</tag><tag>垃圾回收</tag><tag>系统监控</tag></tags><content type="html"><![CDATA[  Tomcat 优化指南 Tomcat 是一个轻量级的 Java Web 应用服务器，其性能主要受 JVM 内存、线程池和垃圾回收策略影响。
1、JVM 内存与垃圾回收 堆内存设置 这是最关键的调优参数。
-Xms512m -Xmx1024m：设置 JVM 堆内存的初始大小（-Xms）和最大大小（-Xmx）。 建议将 -Xms 和 -Xmx 设置为相同值，以避免运行时堆内存动态调整带来的性能波动。具体数值应根据服务器可用物理内存和应用需求而定，例如可设置为系统物理内存的80%左右。 选择垃圾回收器 -XX:+UseG1GC：对于需要低延迟的应用，推荐使用 G1 垃圾回收器，它能在延迟和吞吐量间取得较好平衡。 2、连接器与线程池优化 在 conf/server.xml 中优化 HTTP 连接器 (&amp;lt;Connector&amp;gt;)。
核心配置参数 1 2 3 4 5 6 7 &amp;lt;Connector protocol=&amp;#34;HTTP/1.1&amp;#34; maxThreads=&amp;#34;200&amp;#34; minSpareThreads=&amp;#34;25&amp;#34; acceptCount=&amp;#34;100&amp;#34; connectionTimeout=&amp;#34;20000&amp;#34; redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; 参数说明 协议：使用 NIO 协议（protocol=&amp;quot;HTTP/1.1&amp;quot;），其并发性能更好。 线程池： maxThreads=&amp;quot;200&amp;quot;：最大工作线程数，应根据系统负载和CPU核心数调整。 minSpareThreads=&amp;quot;25&amp;quot;：最小空闲线程数，用于快速响应突发请求。 acceptCount=&amp;quot;100&amp;quot;：当所有可用线程都被占用时，传入连接请求的最大队列长度。 3、应用部署与安全 部署优化 将静态资源（如图片、CSS、JS）交由 Nginx 等前端服务器处理，减轻 Tomcat 负担。 使用反向代理配置，让 Nginx 处理静态内容，Tomcat 专注于动态请求处理。 安全加固 以非 root 用户运行 Tomcat 禁用不需要的 AJP 连接器（通常可注释掉）： 1 2 3 4 5 6 &amp;lt;!-- &amp;lt;Connector …  ]]></content></entry><entry><title>Tomcat安装部署指南 Ubuntu 24.04 aarch64架构详细教程</title><url>/post/operations/tomcat-installation-ubuntu-24-04-aarch64/</url><categories><category>运维</category><category>部署</category></categories><tags><tag>Tomcat</tag><tag>Ubuntu</tag><tag>Linux</tag><tag>Java</tag><tag>服务器配置</tag><tag>aarch64</tag><tag>Web服务器</tag></tags><content type="html"><![CDATA[  Tomcat 安装部署（Ubuntu 24.04 aarch64） 安装 Java 环境 Tomcat 依赖于 Java 环境，Ubuntu 24.04 上建议安装 OpenJDK 17。
更新软件包序列 在终端中执行以下命令：
1 sudo apt update 安装 OpenJDK 17 1 2 # 安装 OpenJDK 17 sudo apt install openjdk-17-jdk -y 验证安装 安装完成后，通过以下命令验证 Java 是否安装成功：
1 java -version 如果安装正确，终端会显示类似 openjdk version &quot;17.0.13&quot; 这样的版本信息。
下载并安装 Tomcat 建议为 Tomcat 创建一个专用的系统用户和目录，以便管理。
创建 Tomcat 用户和组 执行以下命令创建一个不能登录系统的 tomcat 用户和组：
1 2 sudo groupadd tomcat sudo useradd -s /bin/false -g tomcat -d /opt/tomcat tomcat 下载 Tomcat 访问 Apache Tomcat 官网 下载适用于 aarch64 的二进制发行版。你可以直接在服务器上使用 wget 命令下载。请根据你的需要选择版本（例如 Tomcat 10.1.x, 11.0.x）。
1 2 # 以 Tomcat 11.0.13 为例，进入一个临时目录下载 wget -O tomcat.tar.gz https://dlcdn.apache.org/tomcat/tomcat-11/v11.0.13/bin/apache-tomcat-11.0.13.tar.gz 解压并设置目录权限 将下载的 Tomcat 解压到 /opt 目录，并调整所有权。
1 2 3 4 5 6 7 8 # 创建目标目录并解压 sudo mkdir -p /opt/tomcat sudo tar -xvzf tomcat.tar.gz -C /opt/tomcat --strip-components=1 # 将Tomcat目录的所有权赋予tomcat用户 sudo chown -R tomcat:tomcat /opt/tomcat # 为conf目录设置适当的读写权限给tomcat组 sudo chmod -R g+r /opt/tomcat/conf sudo chmod g+x /opt/tomcat/conf 配置环境变量 设置 CATALINA_HOME 环境变量可以方便地指向你的 Tomcat 安装目录。
编辑当前用户的 ~/.bashrc 文件：
1 nano ~/.bashrc 在文件末尾添加以下内容：
1 2 export CATALINA_HOME=/opt/tomcat export PATH=$PATH:$CATALINA_HOME/bin 保存并退出编辑器。
让配置立即生效：
1 source ~/.bashrc 启动 Tomcat 并验证 启动 Tomcat 你可以直接运行启动脚本：
1 $CATALINA_HOME/bin/startup.sh 如果看到类似 &quot;Tomcat started.&quot; 的提示，说明启动成功。
验证安装 打开你的浏览器，访问 http://&lt;你的服务器IP地址&gt;:8080。
如果看到 Apache Tomcat 的默认欢迎页面，就说明 Tomcat 已经成功安装并运行。
  ]]></content></entry><entry><title>Nginx性能优化指南 核心配置调优与缓存策略实战</title><url>/post/operations/nginx-optimization/</url><categories><category>运维</category><category>性能优化</category></categories><tags><tag>Nginx</tag><tag>性能调优</tag><tag>Web服务器</tag><tag>缓存</tag><tag>负载均衡</tag><tag>系统优化</tag></tags><content type="html">  Nginx 优化指南 Nginx 是一个高性能的 Web 服务器、反向代理服务器和负载均衡器。其优化核心在于合理利用系统资源，高效处理并发连接。
1、核心配置调优 worker进程与连接数 worker_processes auto;：设置为 auto 可自动匹配 CPU 核心数，充分利用多核。 worker_connections 4096;：提高每个 worker 进程能处理的并发连接数（需结合系统限制调整）。你需要检查并调整 Linux 系统的文件描述符限制（nofile）以支持该值。 高效网络传输 sendfile on;：启用 sendfile 系统调用，减少文件传输中的上下文切换和数据拷贝，提升静态资源传输效率。 tcp_nopush on;：与 sendfile 配合，确保数据包满载后再发送，提升网络效率。 连接复用 keepalive_timeout 30s; 与 keepalive_requests 100;：保持客户端连接一定时间，允许在该连接上发送多个请求，减少 TCP 连接建立和断开的开销。 缓冲与限制 设置 client_max_body_size 10m; 限制客户端请求体大小，防止超大请求耗尽资源。 使用 limit_conn_zone 和 limit_conn 限制单一 IP 的并发连接数，防止滥用。 2、缓存与压缩 启用压缩 启用 Gzip 压缩可以减少传输数据量。
1 2 3 gzip on; gzip_comp_level 6; # 压缩级别，1-9，通常6是性能与压缩比的良好平衡 gzip_types text/plain text/css application/json; # 指定需要压缩的文件类型 代理缓存 缓存后端响应可以显著减轻上游服务器压力。
1 2 proxy_cache_path /data/cache levels=1:2 keys_zone=my_cache:10m max_size=10g; proxy_cache_key &amp;#34;$scheme$request_method$host$request_uri&amp;#34;; # 定义缓存键 然后在 location 块中使用 proxy_cache my_cache; 启用缓存。
3、维护与监控 日志分析：定期分析 /var/log/nginx/access.log 和 error.log，排查异常请求和错误。 配置管理：每次修改配置后，使用 nginx -t 测试语法正确性，然后通过 systemctl reload nginx 平滑重载配置。 状态监控：编译时启用 ngx_http_stub_status_module 模块，通过内置页面实时监控连接数、请求数等关键指标。 定期更新：通过包管理工具（如 apt）定期更新 Nginx，以获取性能改进和安全补丁。   </content></entry><entry><title>Nginx安装部署指南 Ubuntu 24.04 aarch64架构详细教程</title><url>/post/operations/nginx-installation-ubuntu-24-04-aarch64/</url><categories><category>运维</category><category>部署</category></categories><tags><tag>Nginx</tag><tag>Ubuntu</tag><tag>Linux</tag><tag>Web服务器</tag><tag>aarch64</tag><tag>服务器配置</tag><tag>系统管理</tag></tags><content type="html"><![CDATA[  Nginx 安装部署（Ubuntu 24.04 aarch64） 安装与基础配置 步骤 核心命令/操作 说明 安装 sudo apt update &amp;&amp; sudo apt install nginx -y 从 Ubuntu 官方仓库安装 Nginx。 管理服务 sudo systemctl start nginx
sudo systemctl enable nginx
sudo systemctl status nginx 启动、设置开机自启、检查服务状态。 配置防火墙 sudo ufw allow 'Nginx Full' 允许 HTTP(80) 和 HTTPS(443) 流量。 测试运行 浏览器访问 http://你的服务器IP 看到 Nginx 欢迎页即表示安装成功。 验证配置 sudo nginx -t 检查配置文件语法是否正确。 重载配置 sudo systemctl reload nginx 应用修改后的配置，无需重启服务。 配置网站（服务器块） Nginx 使用&quot;服务器块&quot;（类似于虚拟主机）来托管多个网站。
创建服务器块配置 在 /etc/nginx/sites-available/ 目录下为网站创建配置文件，例如 example.com。
1 sudo nano /etc/nginx/sites-available/example.com 将以下配置粘贴到文件中，请务必将 server_name 和 root 路径替换为你自己的域名和网站目录。
1 2 3 4 5 6 7 8 9 10 11 server { listen 80; server_name example.com www.example.com; root /var/www/example.com/html; index index.html index.htm; location / { try_files $uri $uri/ =404; } } 创建网站目录及文件 为你的网站创建一个根目录，并添加测试页面。
1 2 3 4 sudo mkdir -p /var/www/example.com/html sudo chown -R $USER:$USER /var/www/example.com/html chmod -R 755 /var/www/example.com echo &#39;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#39; | sudo tee /var/www/example.com/html/index.html 以上命令创建了目录 /var/www/example.com/html，并设置了权限和测试页面。
启用配置 通过在 sites-enabled 目录创建符号链接来启用此配置。
1 sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/ 测试并应用 最后，测试配置并重新加载 Nginx。
1 2 sudo nginx -t # 测试配置语法 sudo systemctl reload nginx # 应用新配置 进阶配置与故障排查 关键目录与文件 主配置文件：/etc/nginx/nginx.conf 可用站点配置：/etc/nginx/sites-available/ 已启用站点配置：/etc/nginx/sites-enabled/ 默认网站根目录：/var/www/html 日志文件：/var/log/nginx/access.log 和 /var/log/nginx/error.log 常见问题排查 端口占用：使用 sudo ss -tulnp | grep :80 检查 80 端口是否被其他程序占用。 配置语法错误：务必在重载前执行 sudo nginx -t 来验证。 权限问题：如果遇到 403 Forbidden，请检查网站根目录及其父目录的权限是否允许 Nginx 进程（通常是 www-data 用户）读取。   ]]></content></entry><entry><title>PoE以太网供电技术详解：标准类型与功率参数全解析</title><url>/post/operations/power-over-ethernet-poe-explained/</url><categories><category>运维</category><category>网络</category></categories><tags><tag>PoE</tag><tag>以太网</tag><tag>供电技术</tag><tag>IEEE标准</tag><tag>网络设备</tag><tag>技术解析</tag></tags><content type="html">  定义 以太网供电PoE（Power over Ethernet）是指通过以太网网络为基于IP的终端传输数据的同时进行直流供电，也被称为基于局域网的供电系统PoL（Power over LAN）或有源以太网（Active Ethernet）。 一个完整的PoE系统包括供电端设备（PSE, Power Sourcing Equipment）和受电端设备（PD, Power Device）两部分。
PoE标准 PoE类型 Type 1 Type 2 Type 3 Type 4 供电技术 PoE PoE+ PoE++ PoE++ 供电标准 IEEE 802.3af IEEE 802.3at IEEE 802.3bt IEEE 802.3bt 供电距离 100M 100M 100M 100M 分级 0-3 0-4 0-6 0-8 最大电流 350mA 600mA 1730mA 1730mA PSE输出电压 44V DC-57V DC 44V DC-57V DC 44V DC-57V DC 52V DC-57V DC PSE输出功率 ≤ 15.40 W ≤ 30.00 W 60W 90W PD输入电压 36V DC-57V DC 42.5V DC-57V DC 39.9V DC- 57V DC 52V DC-57V DC PD最大功率 12.95W 25.50W 51.00-60.00W 71.00-90.00W 线缆要求 Cat3及以上 Cat5E及以规格 Cat5E及以规格 Cat5E及以规格 供电线缆对 2 2 4 4 分级 PSE端 Class 0 Class 1 Class 2 Class 3 Class 4 Class 5 Class 6 Class 7 Class 8 15.4W 4W 7W 15.4W 30W 45W 60W 75W 90W PD端 Class 0 Class 1 Class 2 Class 3 Class 4 Class 5 Class 6 Class 7 Class 8 0W-12.95W 3.84W 6.49W 6.49W-12.95W 25.5W 40W 51W 62W 71.3W PSE Type与功率分级的关系 PSE Type Event数 最高分配等级 Type 1 1 Class 3 Type 2 2 Class 4 Type 3 4 Class 6 Type 4 5 Class 8 PD分级与PSE端检测电流的关系 PD分级 PSE端检测电流 PSE端分级签名 Class 0 0-5mA 0 Class 1 8-13mA 1 Class 2 16-21mA 2 Class 3 25-31mA 3 Class 4 35-45mA 4   </content></entry><entry><title>AMD锐龙系列CPU异常卡顿问题探讨</title><url>/post/operations/amd-ryzen-stuttering-issue-analysis/</url><categories><category>运维</category><category>系统优化</category></categories><tags><tag>AMD</tag><tag>CPU</tag><tag>Windows10</tag><tag>Windows11</tag><tag>系统优化</tag><tag>性能调优</tag><tag>游戏</tag></tags><content type="html">  游戏帧数高却异常卡顿的问题 在网上看见部分AMD锐龙CPU使用者在Windows10/11系统下玩游戏时帧数很高却时不时能感到卡顿，此类现象推测可能跟以下系统设置有关。
一、高精度事件计时器（HPET） 高精度事件计时器（英语：High Precision Event Timer，缩写HPET），也称高精度事件定时器，它是个人计算机中使用的一种硬件计时器，由英特尔（Intel）与微软共同开发，并自2005年以来已被纳入PC芯片组。英特尔以前曾有多媒体计时器（Multimedia Timer），因此选择了HPET作为术语，避免与作为软件特性在Windows 3.0中引入到多媒体扩展的多媒体计时器混淆。
Windows10/11系统会默认开启这两个功能，在早期的论坛反馈中经常提及启用HPET会导致AMD的CPU偶尔卡顿。
关闭方法 以管理员身份运行命令提示符，在命令提示符窗口中按顺序输入并运行以下指令：
1 2 bcdedit /set useplatformclock false bcdedit /deletevalue useplatformclock 执行完后出现“操作成功完成”即可。
启用方法 以管理员身份运行命令提示符，在命令提示符窗口中按顺序输入并运行以下指令：
1 bcdedit /set useplatformclock true 二、异类线程调度 微软为了解决英特尔的CPU的大小核优化问题默认启用的功能
关闭方法 以管理员身份运行命令提示符，在命令提示符窗口中按顺序输入并运行以下指令： 1 2 powercfg -attributes SUB_PROCESSOR 93b8b6dc-0698-4d1c-9ee4-0644e900c85d -ATTRIB_HIDE powercfg -attributes SUB_PROCESSOR bae08b81-2d5e-4688-ad6a-13243356654b -ATTRIB_HIDE 进入“电源选项”选择“高性能”或“卓越性能” 依次单击“更改计划设置”-“更改高级电源设置”，在“电源选项”窗口中将“处理器电源管理”-“异类线程调度策略”改成“所有处理器”，将“处理器电源管理”-“异类短运行线程调度策略”改成“所有处理器”之后单击“确定”   </content></entry><entry><title>Padavan系统优化探索</title><url>/post/operations/padavan-system-optimization/</url><categories><category>运维</category><category>系统优化</category></categories><tags><tag>Padavan</tag><tag>iptables</tag><tag>防火墙</tag><tag>conntrack</tag><tag>路由器优化</tag><tag>CPU</tag><tag>网络性能</tag><tag>性能调优</tag><tag>Shell</tag></tags><content type="html"><![CDATA[  防火墙开放端口（iptables） 【在防火墙规则启动后执行】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/bin/sh /etc/storage/crontabs_script.sh &amp; export PATH=&#39;/etc/storage/bin:/tmp/script:/etc/storage/script:/opt/usr/sbin:/opt/usr/bin:/opt/sbin:/opt/bin:/usr/local/sbin:/usr/sbin:/usr/bin:/sbin:/bin&#39; export LD_LIBRARY_PATH=/lib:/opt/lib iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu ip6tables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu logger -t &#34;【防火墙规则】&#34; &#34;解决 PMTU 黑洞成功.&#34; ip6tables -F ip6tables -X ip6tables -P INPUT ACCEPT ip6tables -P OUTPUT ACCEPT ip6tables -P FORWARD ACCEPT logger -t &#34;【防火墙规则】&#34; &#34;IPv6端口开放成功.&#34; ip6tables -A INPUT -p tcp --dport 8088 -j ACCEPT ip6tables -A OUTPUT -p tcp --sport 8088 -j ACCEPT httpd -p 8088 logger -t &#34;【防火墙规则】&#34; &#34;IPv6 8088端口转发成功.&#34; logger -t &#34;【防火墙规则】&#34; &#34;脚本完成.&#34; 连接数优化【在路由器初始化前执行】（三选一） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # conntrack for BT/PT/PCDN echo 0 &gt; /proc/sys/net/netfilter/nf_conntrack_checksum echo 1 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_loose echo 1 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_be_liberal echo 10 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_syn_sent echo 10 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_syn_recv echo 86400 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_established echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_fin_wait echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_close_wait echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_last_ack echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_time_wait echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_close echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_udp_timeout echo 180 &gt; /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_icmp_timeout echo 600 &gt; /proc/sys/net/netfilter/nf_conntrack_generic_timeout # conntrack(优化连接数) echo 0 &gt; /proc/sys/net/netfilter/nf_conntrack_checksum echo 1 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_be_liberal echo 1 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_loose echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_syn_sent echo 15 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_syn_recv echo 1800 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_established echo 30 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_fin_wait echo 30 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_close_wait echo 30 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_last_ack echo 30 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_time_wait echo 30 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_close echo 30 &gt; /proc/sys/net/netfilter/nf_conntrack_udp_timeout echo 120 &gt; /proc/sys/net/netfilter/nf_conntrack_udp_timeout_stream echo 30 &gt; /proc/sys/net/netfilter/nf_conntrack_icmp_timeout echo 600 &gt; /proc/sys/net/netfilter/nf_conntrack_generic_timeout # conntrack(原版) echo 0 &gt; /proc/sys/net/netfilter/nf_conntrack_checksum echo 1 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_be_liberal echo 300 &gt; /proc/sys/net/netfilter/nf_conntrack_generic_timeout echo 1800 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_established echo 30 &gt; /proc/sys/net/netfilter/nf_conntrack_icmp_timeout echo 50 &gt; /proc/sys/net/netfilter/nf_conntrack_udp_timeout CPU多核利用率优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 vi /etc/storage/bin/rps-rfs-ops.sh #!/bin/sh set_rps_rfs() { echo f &gt;/proc/irq/11/smp_affinity echo f &gt;/proc/irq/12/smp_affinity for device in $(ls /sys/class/net); do echo f &gt;/sys/class/net/$device/queues/rx-0/rps_cpus echo 32768 &gt;/sys/class/net/$device/queues/rx-0/rps_flow_cnt done echo 32768 &gt;/proc/sys/net/core/rps_sock_flow_entries } get_rps_rfs() { cat /proc/irq/11/smp_affinity cat /proc/irq/12/smp_affinity for device in $(ls /sys/class/net); do printf &#34;%-10s %-5s %-10s\n&#34; &#34;$device&#34; &#34;$(cat /sys/class/net/$device/queues/rx-0/rps_cpus)&#34; &#34;$(cat /sys/class/net/$device/queues/rx-0/rps_flow_cnt)&#34; done cat /proc/sys/net/core/rps_sock_flow_entries } case $1 in get) get_rps_rfs ;; set) set_rps_rfs ;; *) get_rps_rfs ;; esac chmod a+x /etc/storage/bin/rps-rfs-ops.sh chmod go-w /etc/storage/bin/rps-rfs-ops.sh rps-rfs-ops.sh这个文件并不存在，需要自己复制内容新建一个，或者传一个上去； 需要分别在下面二个位置调用这段脚本“rps-rfs-ops.sh set”：
1 2 rps-rfs-ops.sh set logger -t &#34;【网络检测】&#34; &#34;CPU多核利用率优化完成.&#34; 自定义设置-&gt;脚本-&gt;在路由器启动后执行
自定义设置-&gt;网络检测-&gt;在网络访问状态改变时运行脚本
  ]]></content></entry><entry><title>基于STC89C52单片机的智能循迹小车：从设计到实现</title><url>/post/development/line-follower-car-89c52/</url><categories><category>开发</category><category>嵌入式</category></categories><tags><tag>项目</tag><tag>开发</tag><tag>嵌入式</tag><tag>C</tag><tag>小车</tag></tags><content type="html">   一个融合了自动控制与人机交互的嵌入式项目实践
项目背景 在嵌入式系统和智能控制领域，循迹小车是一个经典而又实用的入门项目。它不仅涵盖了传感器数据采集、电机控制、算法处理等核心技术，还涉及人机交互和异常处理等实用功能。今天，我要向大家分享一个基于STC89C52单片机的智能循迹小车项目，这个项目完美诠释了&amp;amp;quot;麻雀虽小，五脏俱全&amp;amp;quot;的设计理念。
项目概述 这个智能循迹小车以STC89C52单片机为核心控制器，通过红外传感器检测路面黑色轨迹，实现自动循迹功能。同时，项目还提供了手动控制模式，支持前进、后退、左转、右转等操作，并配备了LED流水灯效果、蜂鸣器报警等丰富的交互功能。整个项目代码结构清晰，功能完善，是一个非常适合作为单片机学习和实践的范例。
硬件架构 核心组件 主控制器：STC89C52单片机 传感器模块：双路红外光电传感器（左、右各一个，用于轨迹检测） 驱动模块：直流电机 + H桥驱动电路 人机交互： 4个独立按键（手动控制：后退、左转、右转） LED指示灯（P1口控制，实现流水灯效果） 蜂鸣器（异常状态报警） 硬件连接 P1端口：LED指示灯 P2端口：电机驱动控制（Left_A, Left_B, Right_A, Right_B） P3端口：按键输入和红外传感器信号采集 蜂鸣器：独立控制引脚，用于状态提示和报警 软件设计 代码结构 项目采用模块化设计，代码结构清晰：
1 2 3 4 ├── main.c # 主程序文件，包含初始化和主循环 ├── driver.c # 驱动程序，包含电机控制、循迹算法等核心功能 ├── driver.h # 头文件，定义引脚映射和函数声明 └── README.md # 项目说明文档 核心功能模块 1. 电机控制 项目实现了精确的PWM波形控制，通过软件延时生成PWM信号，实现电机速度调节：
1 2 3 4 5 6 7 8 9 void forward() { Right_A = 1; Right_B = 0; Left_B = 0; Left_A = 1; delay_ms(17); // PWM占空比控制 Left_A = 0; delay_ms(3); } 2. 智能循迹算法 循迹算法是项目的核心，通过分析左右红外传感器的状态，智能判断小车行进方向：
1 2 3 4 5 6 7 8 9 10 11 …  </content></entry><entry><title>macOS Big Sur 11.5.2 适用于 联想启天M410-B069台式电脑 的 OpenCore EFI 分享</title><url>/post/system/hackintosh/opencore-efi-for-lenovo-m410-b069/</url><categories><category>系统</category><category>黑苹果</category></categories><tags><tag>Hackintosh</tag><tag>macOS</tag><tag>OpenCore</tag><tag>联想</tag></tags><content type="html">  前言 暑假见家中闲置的联想品牌主机折腾的想法油然而生，折腾一下午后成功点亮，理论上支持同类型品牌主机。
注： 本 EFI 采用 OpenCore 0.7.1 引导，在使用前请阅读：
OpenCore 官方文档 – OpenCore 最权威的资料 OpenCore Configurator – 适用于 OpenCore 的 config.plist 编辑工具 本EFI已针对机型定制USB
配置 Type Name CPU Intel i3-6100 MB Intel Kabylake B250 Audio Realtek RTL ALC662 GPU Intel HD Graphics 530 RAM 8GB 2133MHz DDR4 Ethernet Realtek 8111GN Wireless&amp;amp;Bluetooth None 来源 OpenCore 0.71 by OpenCorePkg Audio by AppleALC alcid=5 Graphics by WhateverGreen WIFI by AirportBrcmFixup (brcmfx-country=#a) Bluetooth by BrcmPatchRAM and nickhx from osxlatitude 已知问题 系统概览中CPU显示为 3.7GHz 双核 Intel Core i5 核显 HD 530 设备ID只有仿冒 Platform-Id 为 0x193b0005 才能正常进系统并驱动，但 0x193b0005在 黑果小兵的部落阁的文章中 的显卡为 Intel HD Graphics 530/4K* 在 黑苹果屋的文章中 的显卡为 Intel Iris Pro Graphics 580 不知道会不会有其他影响，我猜测联想启天M410主机后的HDMI接口走的是LVDS通道故使用其他530的ID不能驱动成功 睡眠后不能正常唤醒 下载 百度云（提取码：Qing） 蓝奏云（密码：Qing）   </content></entry><entry><title>从零开始：在嵌入式Linux平台上实现2048游戏</title><url>/post/development/embedded-2048-game-design/</url><categories><category>开发</category><category>嵌入式</category></categories><tags><tag>项目</tag><tag>开发</tag><tag>嵌入式</tag><tag>C</tag><tag>游戏</tag></tags><content type="html">  引言 在嵌入式系统与设计实训课程中，我选择了一个既有趣又具挑战性的项目：在资源受限的嵌入式Linux平台上实现经典的2048游戏。这个看似简单的游戏实际上涵盖了嵌入式开发的多个核心知识点——硬件驱动、用户交互、资源管理和性能优化。本文将分享我在开发过程中遇到的技术挑战、解决方案以及收获的经验。
项目背景 2048是一款风靡全球的数字益智游戏，其规则简单但极具挑战性。选择在嵌入式平台上实现它，不仅是为了完成课程作业，更是为了探索如何在资源受限的环境中提供流畅的用户体验。本项目运行在ARM架构的Linux开发板上，通过直接操作LCD屏幕和触摸屏设备，实现了完整的游戏功能。
技术架构 系统架构图 1 2 3 4 5 6 7 ┌───────────────────────────────────┐ │ 应用层 (2048游戏) │ ├───────────────────────────────────┤ │ 中间层 (LCD/BMP/Touch驱动) │ ├───────────────────────────────────┤ │ 硬件层 (LCD/触摸屏) │ └───────────────────────────────────┘ 核心模块 显示模块：直接操作Framebuffer，实现LCD屏幕初始化、图像显示 图像处理模块：支持BMP格式图片解码和显示 输入模块：解析触摸屏事件，识别滑动手势方向 游戏逻辑模块：实现2048核心算法，包括移动、合并、随机生成等 状态管理模块：维护游戏状态，判断胜负条件 代码实现解析 1. 游戏数据结构 1 2 3 4 5 6 int game[4][4] = { 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0 }; 游戏状态使用4×4二维数组表示，0表示空单元格，其他数字代表对应数值的方块。这种简单直观的数据结构便于实现移动和合并算法。
2. 随机数生成策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void getRand() { srand(time(NULL)); int i,j; int count = 0; //记录空白位置的个数 int a[16]; //保存空白位置的行下标 int b[16]; …  </content></entry><entry><title>适用 Ryzen R7 B450 的 OpenCore EFI for macOS Catalina 10.15.3</title><url>/post/system/hackintosh/opencore-efi-for-b450/</url><categories><category>系统</category><category>黑苹果</category></categories><tags><tag>Hackintosh</tag><tag>macOS</tag><tag>OpenCore</tag></tags><content type="html">  本 EFI 采用 OpenCore 引导，在使用前请阅读 OpenCore 官方文档 – OpenCore 最权威的资料
OpenCore Configurator – 适用于 OpenCore 的 config.plist 编辑工具
下载链接 蓝奏云 百度网盘 （提取码：imcw）
配置 受春节和疫情影响，计划购置的 DW1820A 无法发货，暂时只加入了无线和蓝牙驱动没有办法调试，理论上支持Airdrop 和 Handoff
Type Name CPU AMD Ryzen 3700X MB MSI B450M MORTAR MAX Audio Realtek ALC892 Codec GPU PowerColor Radeon Vega 64 RAM Kingston 32GB 3600MHz DDR4 (16G * 2) Ethernet Realtek RTL8111H-CG Wireless &amp;amp; Bluetooth None Type Name CPU AMD Ryzen 2700 MB MSI B450I MORTAR MAX Audio Realtek ALC887 Codec GPU XFX Radeon RX 580 8G 2304sp RAM Gloway 16GB 3000MHz DDR4 (16G * 1) Ethernet Realtek 8111H Gigabit LAN controller Wireless &amp;amp; Bluetooth None 来源 OpenCore by OpenCorePkg Audio by AppleALC Graphics by WhateverGreen WIFI by AirportBrcmFixup (brcmfx-country=#a) Bluetooth by BrcmPatchRAM and nickhx from osxlatitude 已知问题 Realtek ALC887 声卡暂未驱动成功 不支持 32-bit 不能运行 Android 模拟器，因为 Android 模拟器只支持 VT-X ，但是支持AMD-V的 Genymotion 和 Virtualbox 可以运行 Github B450-Hackintosh   </content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html">  关于我 一个正在学习CS&amp;amp;EE的小白，用Blog来记录学习生活中的点点滴滴。
要是无法讨好全世界，就先讨好自己吧！
WeChat: YiQing_Official
  </content></entry><entry><title>读书郎</title><url>/post/the-bookish-youth.html</url><categories><category>诗歌</category></categories><tags><tag>诗歌</tag></tags><content type="html">  夜影落寒窗，持卷入梦床。
经年风雨雪，烛下捧茶凉。
刺骨悬梁瘦，书生昼夜忙。
图谋功与利，遥盼状元郎。
（五律仄起入韵）
  </content></entry><entry><title>浣溪沙·雨夜有感</title><url>/post/riverside-sand-reflections-on-a-rainy-night.html</url><categories><category>诗歌</category></categories><tags><tag>诗歌</tag></tags><content type="html">  夜雨淋湿鹦鹉枝，梧桐灯下子规啼，红消香断小荷池。
翠幕摇风纱帐冷，朱檐水漏墨痕稀，此时难奈是相思。
  </content></entry><entry><title>满江红·流火将消</title><url>/post/the-river-runs-red-as-the-fire-star-fades.html</url><categories><category>诗歌</category></categories><tags><tag>诗歌</tag></tags><content type="html">  流火将消，天边眺、海霞初见。
回首望，旦暝几度，渐行渐远。
易逝韶华何必论，来年夏至凌绝顶。
逐浪儿，今放手一搏，无牵念。
万里路，千里卷，
年少梦，谁能灭！
定长驱策马，乘风跋浪。
笔蘸三江飞瀑墨，胸怀赤子横眉剑。
莫负心，望锦绣前程，朝天阙。
  </content></entry><entry><title>站点示例</title><url>/flinks.html</url><categories/><tags/><content type="html">  如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
1 2 3 4 - name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org   </content></entry></search>